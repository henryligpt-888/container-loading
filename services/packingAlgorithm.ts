import { BoxItem, Dimensions } from '../types';

// A generic point in 3D space
type Point = [number, number, number];

/**
 * Checks if two boxes overlap.
 * Box A is existing placed box, Box B is the new candidate.
 */
const checkOverlap = (
  posA: Point, dimA: Dimensions,
  posB: Point, dimB: Dimensions
): boolean => {
  const [ax, ay, az] = posA;
  const [bx, by, bz] = posB;

  // Standard AABB overlap check
  const overlapX = ax < bx + dimB.width && ax + dimA.width > bx;
  const overlapY = ay < by + dimB.height && ay + dimA.height > by;
  const overlapZ = az < bz + dimB.depth && az + dimA.depth > bz;

  return overlapX && overlapY && overlapZ;
};

/**
 * Checks if a specific position is valid for a new box given constraints.
 */
const isValidPosition = (
  pos: Point,
  box: BoxItem,
  placedBoxes: BoxItem[],
  container: Dimensions
): boolean => {
  const [x, y, z] = pos;

  // 1. Boundary Check
  if (x + box.width > container.width) return false;
  if (y + box.height > container.height) return false;
  if (z + box.depth > container.depth) return false;

  // 2. Collision & Constraint Check with all existing boxes
  for (const other of placedBoxes) {
    if (!other.position) continue;

    // Physical Collision Check
    if (checkOverlap(
      other.position, { width: other.width, height: other.height, depth: other.depth },
      pos, { width: box.width, height: box.height, depth: box.depth }
    )) {
      return false;
    }

    // "No Stacking Above" Logic
    // If the 'other' box forbids stacking, we ensure the new box is not "above" it.
    // We define "above" as: overlapping in X/Z plane AND new box's Y >= other box's Y.
    if (other.cantStackTop) {
      const overlapX = x < other.position[0] + other.width && x + box.width > other.position[0];
      const overlapZ = z < other.position[2] + other.depth && z + box.depth > other.position[2];
      
      if (overlapX && overlapZ) {
        // If we overlap horizontally, we must check vertical relationship.
        // If the new box is placed at a height equal to or greater than the restricted box, it's invalid.
        if (y >= other.position[1]) {
           return false;
        }
      }
    }
  }

  return true;
};

/**
 * Runs the greedy packing simulation.
 * Returns a new array of boxes with updated positions and 'placed' status.
 */
export const calculatePacking = (
  boxes: BoxItem[],
  container: Dimensions
): BoxItem[] => {
  // Deep copy to avoid mutating state directly during calc
  const resultBoxes = boxes.map(b => ({ ...b, position: undefined, placed: false } as BoxItem));

  // Heuristic: Sort by Height (desc), then Volume (desc). 
  // Taller boxes usually harder to place later.
  const sortedIndices = resultBoxes
    .map((box, index) => ({ box, index }))
    .sort((a, b) => {
      if (b.box.height !== a.box.height) return b.box.height - a.box.height;
      const volA = a.box.width * a.box.height * a.box.depth;
      const volB = b.box.width * b.box.height * b.box.depth;
      return volB - volA;
    });

  // Potential placement points. Start with origin.
  // We maintain a list of coordinates where a box corner could potentially go.
  let potentialPoints: Point[] = [[0, 0, 0]];

  const successfullyPlaced: BoxItem[] = [];

  for (const { index } of sortedIndices) {
    const box = resultBoxes[index];
    let placed = false;

    // Sort points to prioritize Bottom, Back, Left (Y -> Z -> X)
    potentialPoints.sort((a, b) => {
      if (a[1] !== b[1]) return a[1] - b[1]; // y
      if (a[2] !== b[2]) return a[2] - b[2]; // z
      return a[0] - b[0]; // x
    });

    for (const point of potentialPoints) {
      if (isValidPosition(point, box, successfullyPlaced, container)) {
        // Place the box
        box.position = point;
        box.placed = true;
        placed = true;
        successfullyPlaced.push(box);

        // Add new potential points generated by this box
        // 1. Top of this box
        potentialPoints.push([point[0], point[1] + box.height, point[2]]);
        // 2. Right of this box
        potentialPoints.push([point[0] + box.width, point[1], point[2]]);
        // 3. Front of this box
        potentialPoints.push([point[0], point[1], point[2] + box.depth]);

        break; // Move to next box
      }
    }
  }

  return resultBoxes;
};